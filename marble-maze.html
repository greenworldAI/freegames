<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>3D Marble Maze</title>
  <style>
    body,html { margin:0; padding:0; overflow:hidden; background:#000; }
    #game-wrapper { position: relative; width:100%; max-width:600px; height:600px; margin:1em auto; }
    #game-container { width:100%; height:100%; }
    .hud {
      position:absolute; top:10px; left:10px;
      color:#fff; font:16px sans-serif; z-index:2;
      background:rgba(0,0,0,0.4); padding:4px 8px; border-radius:4px;
    }
    .hud.right { left:auto; right:10px; }
    #overlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:rgba(0,0,0,0.8); color:#fff;
      display:flex; align-items:center; justify-content:center;
      flex-direction:column; font:1.2em sans-serif;
      opacity:0; pointer-events:none; transition:opacity .3s;
    }
    #overlay.visible { opacity:1; pointer-events:auto; }
    #overlay button {
      margin-top:1em; padding:8px 16px;
      background:#444; border:none; color:#fff; border-radius:4px;
      cursor:pointer;
    }
    #overlay button:hover { background:#555; }
  </style>
</head>
<body>
  <div id="game-wrapper">
    <div id="game-container"></div>
    <div class="hud" id="timer">Time: 0.0s</div>
    <div class="hud right" id="best">Best: --</div>
    <div id="overlay"><div id="msg"></div><button id="btn">Restart</button></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
  (function(){
    const container = document.getElementById('game-container'),
          timerEl   = document.getElementById('timer'),
          bestEl    = document.getElementById('best'),
          overlay   = document.getElementById('overlay'),
          msgEl     = document.getElementById('msg'),
          btn       = document.getElementById('btn');

    let scene, camera, renderer;
    let walls = [], wallBoxes = [], exitBox, marble;
    let vel = new THREE.Vector3();
    const RADIUS = 0.4, FRICTION = 0.98;
    const layout = [
      '##########',
      '#........#',
      '#.####...#',
      '#.#..#.E.#',
      '#.#..#...#',
      '#.####...#',
      '#........#',
      '##########'
    ];
    const ROWS = layout.length, COLS = layout[0].length, CELL = 2;
    let startTime, bestTime = parseFloat(localStorage.getItem('mazeBest'));
    if(isNaN(bestTime)) bestTime = null;
    function updateBestDisplay(){
      bestEl.textContent = 'Best: ' + (bestTime ? bestTime.toFixed(1)+'s' : '--');
    }
    updateBestDisplay();

    function init(){
      overlay.classList.remove('visible');
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60,1,0.1,1000);
      camera.position.set(0,10,10);
      camera.lookAt(0,0,0);

      if(renderer) renderer.dispose();
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.innerHTML='';
      container.appendChild(renderer.domElement);
      window.addEventListener('resize', onResize);
      onResize();

      // lights
      scene.add(new THREE.AmbientLight(0x888888));
      const dir = new THREE.DirectionalLight(0xffffff,0.6);
      dir.position.set(5,10,5);
      scene.add(dir);

      // maze walls & exit
      walls = []; wallBoxes = [];
      layout.forEach((row,r)=>{
        for(let c=0;c<COLS;c++){
          const ch = row[c];
          const x = (c - COLS/2 + .5)*CELL;
          const z = (r - ROWS/2 + .5)*CELL;
          if(ch === '#'){
            const geo = new THREE.BoxGeometry(CELL,1,CELL);
            const mat = new THREE.MeshLambertMaterial({color:0x4444ff});
            const box = new THREE.Mesh(geo,mat);
            box.position.set(x,0.5,z);
            scene.add(box);
            walls.push(box);
            wallBoxes.push(new THREE.Box3().setFromObject(box));
          } else if(ch === 'E'){
            exitBox = new THREE.Box3(
              new THREE.Vector3(x-.5,0,z-.5),
              new THREE.Vector3(x+.5,1,z+.5)
            );
            const geo = new THREE.BoxGeometry(CELL,0.2,CELL);
            const mat = new THREE.MeshLambertMaterial({color:0x00ff00});
            const p = new THREE.Mesh(geo,mat);
            p.position.set(x,0.1,z);
            scene.add(p);
          }
        }
      });

      // marble
      const mgeo = new THREE.SphereGeometry(RADIUS,16,16);
      const mmat = new THREE.MeshLambertMaterial({color:0xff0000});
      marble = new THREE.Mesh(mgeo,mmat);
      marble.position.set((-COLS/2+1.5)*CELL, RADIUS, (-ROWS/2+1.5)*CELL);
      scene.add(marble);
      vel.set(0,0,0);
      startTime = performance.now();
      animate();
    }

    function onResize(){
      const w = container.clientWidth, h = container.clientHeight;
      camera.aspect = w/h; camera.updateProjectionMatrix();
      renderer.setSize(w,h);
    }

    let tiltX = 0, tiltY = 0;
    window.addEventListener('deviceorientation', e => {
      tiltY = THREE.Math.degToRad((e.beta||0) - 45);
      tiltX = THREE.Math.degToRad(e.gamma||0);
    });
    window.addEventListener('keydown', e => {
      const small = .3;
      if(e.key==='ArrowUp')    tiltY = -small;
      if(e.key==='ArrowDown')  tiltY = small;
      if(e.key==='ArrowLeft')  tiltX = -small;
      if(e.key==='ArrowRight') tiltX = small;
    });

    function animate(){
      requestAnimationFrame(animate);
      const acc = new THREE.Vector3(Math.sin(tiltX)*5,0,Math.sin(tiltY)*5);
      vel.addScaledVector(acc,0.016);
      vel.multiplyScalar(FRICTION);
      marble.position.addScaledVector(vel,0.016);

      // wall collision
      wallBoxes.forEach(bb => {
        if(bb.containsPoint(marble.position)){
          marble.position.sub(vel);
          vel.set(0,0,0);
        }
      });

      // exit check
      if(exitBox.containsPoint(marble.position)){
        const t = (performance.now() - startTime)/1000;
        if(bestTime===null || t<bestTime){
          bestTime = t;
          localStorage.setItem('mazeBest', bestTime);
          updateBestDisplay();
        }
        msgEl.innerHTML = `ðŸŽ‰ You Escaped in ${t.toFixed(1)}s`;
        overlay.classList.add('visible');
        return;
      }

      renderer.render(scene,camera);
      timerEl.textContent = 'Time: '+((performance.now()-startTime)/1000).toFixed(1)+'s';
    }

    btn.addEventListener('click', init);
    init();
  })();
  </script>
</body>
</html>
