<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess - Zntrol Freegames</title>
  <link rel="stylesheet" href="assets/chessboard-1.0.0.min.css">
  <style>
    body { font-family: Arial, sans-serif; text-align: center; background-color: #f0f0f0; }
    h2 { color: #333; }
    #board { width: 400px; margin: 20px auto; }
    #status { display: block; margin-top: 10px; }
  </style>
</head>
<body>
  <h2>Chess on Zntrol Freegames</h2>
  <div id="board"></div>
  <p>Status: <span id="status"></span></p>

  <script src="assets/chess.min.js"></script>
  <script src="assets/chessboard-1.0.0.min.js"></script>
  <script>
    var board = null;
    var game = new Chess();
    var $status = document.getElementById('status');

    var pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 200 };
    var pawnSquareTable = [
      0,  0,  0,  0,  0,  0,  0,  0,
      50, 50, 50, 50, 50, 50, 50, 50,
      10, 10, 20, 30, 30, 20, 10, 10,
      5,  5, 10, 25, 25, 10,  5,  5,
      0,  0,  0, 20, 20,  0,  0,  0,
      5, -5,-10,  0,  0,-10, -5,  5,
      5, 10, 10,-20,-20, 10, 10,  5,
      0,  0,  0,  0,  0,  0,  0,  0
    ];
    var knightSquareTable = [
      -50,-40,-30,-30,-30,-30,-40,-50,
      -40,-20,  0,  0,  0,  0,-20,-40,
      -30,  0, 10, 15, 15, 10,  0,-30,
      -30,  5, 15, 20, 20, 15,  5,-30,
      -30,  0, 15, 20, 20, 15,  0,-30,
      -30,  5, 10, 15, 15, 10,  5,-30,
      -40,-20,  0,  5,  5,  0,-20,-40,
      -50,-40,-30,-30,-30,-30,-40,-50
    ];
    var bishopSquareTable = knightSquareTable;
    var rookSquareTable = pawnSquareTable;
    var queenSquareTable = pawnSquareTable;
    var kingSquareTable = [
      -30,-40,-40,-50,-50,-40,-40,-30,
      -30,-40,-40,-50,-50,-40,-40,-30,
      -30,-40,-40,-50,-50,-40,-40,-30,
      -30,-40,-40,-50,-50,-40,-40,-30,
      -20,-30,-30,-40,-40,-30,-30,-20,
      -10,-20,-20,-20,-20,-20,-20,-10,
      20, 20,  0,  0,  0,  0, 20, 20,
      20, 30, 10,  0,  0, 10, 30, 20
    ];

    function evaluateBoard() {
      var totalEvaluation = 0;
      var board = game.board();
      for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
          var piece = board[i][j];
          if (piece) {
            var value = pieceValues[piece.type] * (piece.color === 'w' ? 1 : -1);
            var squareIndex = i * 8 + j;
            var table = piece.type === 'p' ? pawnSquareTable :
                        piece.type === 'n' ? knightSquareTable :
                        piece.type === 'b' ? bishopSquareTable :
                        piece.type === 'r' ? rookSquareTable :
                        piece.type === 'q' ? queenSquareTable : kingSquareTable;
            value += (piece.color === 'w' ? table[squareIndex] : table[63 - squareIndex]) / 100;
            totalEvaluation += value;
          }
        }
      }
      return totalEvaluation;
    }

    function minimax(depth, game, alpha, beta, isMaximizingPlayer) {
      if (depth === 0 || game.game_over()) {
        return [evaluateBoard(), null];
      }

      var possibleMoves = game.moves();
      var bestMove = null;

      if (isMaximizingPlayer) {
        var bestValue = -Infinity;
        for (var i = 0; i < possibleMoves.length; i++) {
          game.move(possibleMoves[i]);
          var [value] = minimax(depth - 1, game, alpha, beta, false);
          game.undo();
          if (value > bestValue) {
            bestValue = value;
            bestMove = possibleMoves[i];
          }
          alpha = Math.max(alpha, bestValue);
          if (beta <= alpha) break;
        }
        return [bestValue, bestMove];
      } else {
        var bestValue = Infinity;
        for (var i = 0; i < possibleMoves.length; i++) {
          game.move(possibleMoves[i]);
          var [value] = minimax(depth - 1, game, alpha, beta, true);
          game.undo();
          if (value < bestValue) {
            bestValue = value;
            bestMove = possibleMoves[i];
          }
          beta = Math.min(beta, bestValue);
          if (beta <= alpha) break;
        }
        return [bestValue, bestMove];
      }
    }

    function makeAIMove() {
      var [value, bestMove] = minimax(3, game, -Infinity, Infinity, false);
      if (bestMove) {
        game.move(bestMove);
        board.position(game.fen());
        updateStatus();
      }
    }

    function onDragStart(source, piece, position, orientation) {
      if (game.game_over()) return false;
      if (piece.search(/^b/) !== -1) return false;
    }

    function onDrop(source, target) {
      var move = game.move({
        from: source,
        to: target,
        promotion: 'q'
      });

      if (move === null) return 'snapback';
      window.setTimeout(makeAIMove, 250);
      updateStatus();
    }

    function onSnapEnd() {
      board.position(game.fen());
    }

    function updateStatus() {
      var status = '';
      var moveColor = game.turn() === 'w' ? 'White' : 'Black';
      if (game.in_checkmate()) {
        status = 'Game over, ' + moveColor + ' is in checkmate.';
      } else if (game.in_draw()) {
        status = 'Game over, drawn position';
      } else {
        status = moveColor + ' to move';
        if (game.in_check()) {
          status += ', ' + moveColor + ' is in check';
        }
      }
      $status.innerHTML = status;
    }

    var cfg = {
      draggable: true,
      position: 'start',
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd
    };
    board = Chessboard('board', cfg);
    updateStatus();
  </script>
</body>
</html>
